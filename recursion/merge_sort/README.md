# Сортировка слиянием

| Ограничение времени | Ограничение памяти |
|---------------------|--------------------|
| 2.5 секунд          | 64Mb               |

Гоше дали задание написать красивую сортировку слиянием. Поэтому Гоше обязательно надо реализовать отдельно функцию merge и функцию `merge_sort`.

* Функция merge принимает один массив и три целочисленных индекса: `left`, `mid`, и `right`. Функция сливает две отсортированные части одного и того же массива в один отсортированный массив. Первая часть массива определяется полуинтервалом $[left, mid)$ массива `array`, а вторая часть – полуинтервалом $[mid, right)$ того же массива `array`. Функция возвращает сливаемый массив.

* Функция `merge_sort` принимает некоторый подмассив, который нужно отсортировать. Подмассив задаётся полуинтервалом — его началом и концом. Функция должна отсортировать передаваемый в неё подмассив, она ничего не возвращает.

* Функция `merge_sort` разбивает полуинтервал на две половинки и рекурсивно вызывает сортировку отдельно для каждой. Затем два отсортированных массива сливаются в один с помощью `merge`.

Заметьте, что в функции передаются именно полуинтервалы $[begin, end)$, то есть правый конец не включается. Например, если вызвать `merge_sort(arr, 0, 4)`, где $arr = [4, 5, 3, 0, 1, 2]$, то будут отсортированы только первые четыре элемента, изменённый массив будет выглядеть как $arr = [0, 3, 4, 5, 1, 2]$.

Реализуйте эти две функции.

Используйте [заготовки кода для данной задачи](https://github.com/Yandex-Practicum/algorithms-templates/tree/main/python/sprint3/K).

## Формат ввода

Передаваемый в функции массив состоит из целых чисел, не превосходящих по модулю $10^9$.
Длина сортируемого диапазона не превосходит $10^5$.

Вы можете ознакомиться с инструкцией по работе с Make на платформе в разделе "Начало тема «Введение в алгоритмы», урок «Оптимизация ввода и вывода»
